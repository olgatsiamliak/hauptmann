<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Snippets' => 
    array (
      'aa526e943d2bfd1aa79c0b3d4056e9fe' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":1,"source":0,"property_preprocess":0,"name":"setPlaceholders","description":"A snippet for getting fields and setting placeholders. Documentation: https:\\/\\/github.com\\/oo12\\/setPlaceholders","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\r\\n * setPlaceholders\\r\\n * Copyright 2013-2014 Jason Grant\\r\\n *\\r\\n * setPlaceholders is free software; you can redistribute it and\\/or modify it under the\\r\\n * terms of the GNU General Public License as published by the Free Software\\r\\n * Foundation; either version 2 of the License, or (at your option) any later\\r\\n * version.\\r\\n *\\r\\n * setPlaceholders is distributed in the hope that it will be useful, but WITHOUT ANY\\r\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\r\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\r\\n *\\r\\n * You should have received a copy of the GNU General Public License along with\\r\\n * setPlaceholders; if not, write to the Free Software Foundation, Inc., 59 Temple\\r\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\r\\n *\\r\\n * @package setPlaceholders\\r\\n * @author Jason Grant\\r\\n *\\r\\n * Documentation, examples, bug reports, etc.\\r\\n * https:\\/\\/github.com\\/oo12\\/setPlaceholders\\r\\n *\\r\\n * Variables\\r\\n * ---------\\r\\n * @var modX $modx\\r\\n *\\r\\n * Properties\\r\\n * ----------\\r\\n * @property integer id\\r\\n * @property string  ph\\r\\n * @property string  prefix\\r\\n * @property boolean output\\r\\n * @property string  delimiter\\r\\n * @property string  placeholders\\r\\n * @property string  sortby\\r\\n * @property string  sortdir\\r\\n * @property boolean processTVs\\r\\n *\\r\\n * See the default properties for a description of each.\\r\\n *\\r\\n * @package setPlaceholders\\r\\n **\\/\\r\\n\\r\\n\\/\\/ check and initialize essential properties\\r\\n$ph = empty($ph) ? array() : explode(\'||\', $ph);\\r\\n$placeholders = empty($placeholders) ? array() : explode(\'||\', $placeholders);\\r\\n$delimiter = isset($delimiter) ? $delimiter : \',\';\\r\\n$output = empty($output) ? FALSE : TRUE;\\r\\n\\r\\n$p = array();  \\/\\/ placeholder storage\\r\\nif ($ph) {\\r\\n\\t$id = empty($id) ? $modx->resource->get(\'id\') : (int) $id;\\r\\n\\t$prefix = isset($prefix) ? $prefix : \'sph.\';\\r\\n\\t$processTVs = empty($processTVs) ? FALSE : TRUE;\\r\\n\\t$sortby = empty($sortby) ? \'menuindex\' : $sortby;\\r\\n\\t$sortdir = empty($sortdir) ? \'ASC\' : $sortdir;\\r\\n\\t$staticCache = empty($staticCache) ? FALSE : TRUE;\\r\\n\\r\\n\\trequire_once MODX_CORE_PATH . \'components\\/setplaceholders\\/model\\/setplaceholders.class.php\';\\r\\n\\tstatic $sph_r_cache = array();  \\/\\/ cache for resource and TV objects\\r\\n\\t$sph = new sph($modx, $sph_r_cache, $id, $sortby, $sortdir, $processTVs);\\r\\n\\r\\n\\tforeach ($ph as $field) {\\r\\n\\t\\t$field = explode(\'!!\', $field);  \\/\\/ separate out any default value\\r\\n\\t\\t$varname = explode(\'==\', $field[0]);  \\/\\/ separate out any user-defined placeholder name\\r\\n\\t\\tif (isset($varname[1])) {  \\/\\/ if there is one, store the placeholder name\\r\\n\\t\\t\\t$field[0] = $varname[1];\\r\\n\\t\\t\\t$varname = trim($varname[0]);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t$varname = $prefix . trim($field[0]);  \\/\\/ go with prefix + field name\\r\\n\\t\\t}\\r\\n\\t\\tforeach ($field as $f) {  \\/\\/ run through the field and all fallbacks till we get a non-empty one\\r\\n\\t\\t\\t$value = $sph->getVal(trim($f));\\r\\n\\t\\t\\tif (!empty($value) || $value === 0)  { break; }  \\/\\/ quit as soon as we get something\\r\\n\\t\\t}\\r\\n\\t\\tif (is_array($value)) {  \\/\\/ special processing for migx\\r\\n\\t\\t\\t$varname .= \'.\';\\r\\n\\t\\t\\t$migx_idx = 1;\\r\\n\\t\\t\\tforeach ($value as $migx_row) {\\r\\n\\t\\t\\t\\tif (is_array($migx_row)) {\\r\\n\\t\\t\\t\\t\\t$migx_notfirst = FALSE;\\r\\n\\t\\t\\t\\t\\tforeach ($migx_row as $k=>$v) {  \\/\\/ set key:value pairs but ignore MIGX_id\\r\\n\\t\\t\\t\\t\\t\\tif ($migx_notfirst || $k !== \'MIGX_id\') {\\r\\n\\t\\t\\t\\t\\t\\t\\t$p[$varname . $k . $migx_idx] = $v;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t$migx_notfirst = TRUE;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t++$migx_idx;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$p[$varname . \'total\'] = $migx_idx - 1;  \\/\\/ set a placeholder with the total # of objects processed\\r\\n\\t\\t}\\r\\n\\t\\telse {  \\/\\/ set any not found items to \'\' so that placeholders will be fully parsed\\r\\n\\t\\t\\t$p[$varname] = ($value === NULL) ? \'\' : $value;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif (!$staticCache)  { $sph_r_cache = array(); }\\r\\n}\\r\\n\\r\\nforeach ($placeholders as $placeholder) { \\/\\/ add any user-defined placeholders\\r\\n\\t$ph = explode(\'==\', $placeholder);\\r\\n\\t$p[ trim($ph[0]) ] = trim($ph[1]);\\r\\n}\\r\\n\\r\\n\\/\\/ Output our results\\r\\n$modx->setPlaceholders($p);\\r\\nreturn $output ? implode($delimiter, $p) : \'\';","locked":0,"properties":"a:10:{s:2:\\"id\\";a:7:{s:4:\\"name\\";s:2:\\"id\\";s:4:\\"desc\\";s:16:\\"prop_sph.id_desc\\";s:4:\\"type\\";s:7:\\"integer\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:12:\\"placeholders\\";a:7:{s:4:\\"name\\";s:12:\\"placeholders\\";s:4:\\"desc\\";s:26:\\"prop_sph.placeholders_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:2:\\"ph\\";a:7:{s:4:\\"name\\";s:2:\\"ph\\";s:4:\\"desc\\";s:16:\\"prop_sph.ph_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:9:\\"delimiter\\";a:7:{s:4:\\"name\\";s:9:\\"delimiter\\";s:4:\\"desc\\";s:23:\\"prop_sph.delimiter_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\",\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"output\\";a:7:{s:4:\\"name\\";s:6:\\"output\\";s:4:\\"desc\\";s:20:\\"prop_sph.output_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"prefix\\";a:7:{s:4:\\"name\\";s:6:\\"prefix\\";s:4:\\"desc\\";s:20:\\"prop_sph.prefix_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:4:\\"sph.\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:10:\\"processTVs\\";a:7:{s:4:\\"name\\";s:10:\\"processTVs\\";s:4:\\"desc\\";s:24:\\"prop_sph.processTVs_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"sortby\\";a:7:{s:4:\\"name\\";s:6:\\"sortby\\";s:4:\\"desc\\";s:20:\\"prop_sph.sortby_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:9:\\"menuindex\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:23:\\"Child\\/Sibling Selectors\\";}s:7:\\"sortdir\\";a:7:{s:4:\\"name\\";s:7:\\"sortdir\\";s:4:\\"desc\\";s:21:\\"prop_sph.sortdir_desc\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:5:\\"value\\";s:3:\\"ASC\\";s:4:\\"text\\";s:3:\\"ASC\\";}i:1;a:2:{s:5:\\"value\\";s:4:\\"DESC\\";s:4:\\"text\\";s:4:\\"DESC\\";}}s:5:\\"value\\";s:3:\\"ASC\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:23:\\"Child\\/Sibling Selectors\\";}s:11:\\"staticCache\\";a:7:{s:4:\\"name\\";s:11:\\"staticCache\\";s:4:\\"desc\\";s:25:\\"prop_sph.staticCache_desc\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:5:\\"value\\";s:1:\\"1\\";s:4:\\"text\\";s:2:\\"On\\";}i:1;a:2:{s:5:\\"value\\";s:1:\\"0\\";s:4:\\"text\\";s:3:\\"Off\\";}}s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:7:\\"Caching\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\r\\n * setPlaceholders\\r\\n * Copyright 2013-2014 Jason Grant\\r\\n *\\r\\n * setPlaceholders is free software; you can redistribute it and\\/or modify it under the\\r\\n * terms of the GNU General Public License as published by the Free Software\\r\\n * Foundation; either version 2 of the License, or (at your option) any later\\r\\n * version.\\r\\n *\\r\\n * setPlaceholders is distributed in the hope that it will be useful, but WITHOUT ANY\\r\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\r\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\r\\n *\\r\\n * You should have received a copy of the GNU General Public License along with\\r\\n * setPlaceholders; if not, write to the Free Software Foundation, Inc., 59 Temple\\r\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\r\\n *\\r\\n * @package setPlaceholders\\r\\n * @author Jason Grant\\r\\n *\\r\\n * Documentation, examples, bug reports, etc.\\r\\n * https:\\/\\/github.com\\/oo12\\/setPlaceholders\\r\\n *\\r\\n * Variables\\r\\n * ---------\\r\\n * @var modX $modx\\r\\n *\\r\\n * Properties\\r\\n * ----------\\r\\n * @property integer id\\r\\n * @property string  ph\\r\\n * @property string  prefix\\r\\n * @property boolean output\\r\\n * @property string  delimiter\\r\\n * @property string  placeholders\\r\\n * @property string  sortby\\r\\n * @property string  sortdir\\r\\n * @property boolean processTVs\\r\\n *\\r\\n * See the default properties for a description of each.\\r\\n *\\r\\n * @package setPlaceholders\\r\\n **\\/\\r\\n\\r\\n\\/\\/ check and initialize essential properties\\r\\n$ph = empty($ph) ? array() : explode(\'||\', $ph);\\r\\n$placeholders = empty($placeholders) ? array() : explode(\'||\', $placeholders);\\r\\n$delimiter = isset($delimiter) ? $delimiter : \',\';\\r\\n$output = empty($output) ? FALSE : TRUE;\\r\\n\\r\\n$p = array();  \\/\\/ placeholder storage\\r\\nif ($ph) {\\r\\n\\t$id = empty($id) ? $modx->resource->get(\'id\') : (int) $id;\\r\\n\\t$prefix = isset($prefix) ? $prefix : \'sph.\';\\r\\n\\t$processTVs = empty($processTVs) ? FALSE : TRUE;\\r\\n\\t$sortby = empty($sortby) ? \'menuindex\' : $sortby;\\r\\n\\t$sortdir = empty($sortdir) ? \'ASC\' : $sortdir;\\r\\n\\t$staticCache = empty($staticCache) ? FALSE : TRUE;\\r\\n\\r\\n\\trequire_once MODX_CORE_PATH . \'components\\/setplaceholders\\/model\\/setplaceholders.class.php\';\\r\\n\\tstatic $sph_r_cache = array();  \\/\\/ cache for resource and TV objects\\r\\n\\t$sph = new sph($modx, $sph_r_cache, $id, $sortby, $sortdir, $processTVs);\\r\\n\\r\\n\\tforeach ($ph as $field) {\\r\\n\\t\\t$field = explode(\'!!\', $field);  \\/\\/ separate out any default value\\r\\n\\t\\t$varname = explode(\'==\', $field[0]);  \\/\\/ separate out any user-defined placeholder name\\r\\n\\t\\tif (isset($varname[1])) {  \\/\\/ if there is one, store the placeholder name\\r\\n\\t\\t\\t$field[0] = $varname[1];\\r\\n\\t\\t\\t$varname = trim($varname[0]);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t$varname = $prefix . trim($field[0]);  \\/\\/ go with prefix + field name\\r\\n\\t\\t}\\r\\n\\t\\tforeach ($field as $f) {  \\/\\/ run through the field and all fallbacks till we get a non-empty one\\r\\n\\t\\t\\t$value = $sph->getVal(trim($f));\\r\\n\\t\\t\\tif (!empty($value) || $value === 0)  { break; }  \\/\\/ quit as soon as we get something\\r\\n\\t\\t}\\r\\n\\t\\tif (is_array($value)) {  \\/\\/ special processing for migx\\r\\n\\t\\t\\t$varname .= \'.\';\\r\\n\\t\\t\\t$migx_idx = 1;\\r\\n\\t\\t\\tforeach ($value as $migx_row) {\\r\\n\\t\\t\\t\\tif (is_array($migx_row)) {\\r\\n\\t\\t\\t\\t\\t$migx_notfirst = FALSE;\\r\\n\\t\\t\\t\\t\\tforeach ($migx_row as $k=>$v) {  \\/\\/ set key:value pairs but ignore MIGX_id\\r\\n\\t\\t\\t\\t\\t\\tif ($migx_notfirst || $k !== \'MIGX_id\') {\\r\\n\\t\\t\\t\\t\\t\\t\\t$p[$varname . $k . $migx_idx] = $v;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t$migx_notfirst = TRUE;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t++$migx_idx;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$p[$varname . \'total\'] = $migx_idx - 1;  \\/\\/ set a placeholder with the total # of objects processed\\r\\n\\t\\t}\\r\\n\\t\\telse {  \\/\\/ set any not found items to \'\' so that placeholders will be fully parsed\\r\\n\\t\\t\\t$p[$varname] = ($value === NULL) ? \'\' : $value;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif (!$staticCache)  { $sph_r_cache = array(); }\\r\\n}\\r\\n\\r\\nforeach ($placeholders as $placeholder) { \\/\\/ add any user-defined placeholders\\r\\n\\t$ph = explode(\'==\', $placeholder);\\r\\n\\t$p[ trim($ph[0]) ] = trim($ph[1]);\\r\\n}\\r\\n\\r\\n\\/\\/ Output our results\\r\\n$modx->setPlaceholders($p);\\r\\nreturn $output ? implode($delimiter, $p) : \'\';"}',
        'guid' => '164d59ce47698988f25de78017274ea0',
        'native_key' => 1,
        'signature' => 'c2fcfd8c4c5ae8cec9175063f1466d46',
      ),
      '138fd632ce78aa3fe0af30dacee5236b' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":2,"source":0,"property_preprocess":0,"name":"sph","description":"An short alias for setPlaceholders","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\r\\n * setPlaceholders\\r\\n * Copyright 2013-2014 Jason Grant\\r\\n *\\r\\n * setPlaceholders is free software; you can redistribute it and\\/or modify it under the\\r\\n * terms of the GNU General Public License as published by the Free Software\\r\\n * Foundation; either version 2 of the License, or (at your option) any later\\r\\n * version.\\r\\n *\\r\\n * setPlaceholders is distributed in the hope that it will be useful, but WITHOUT ANY\\r\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\r\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\r\\n *\\r\\n * You should have received a copy of the GNU General Public License along with\\r\\n * setPlaceholders; if not, write to the Free Software Foundation, Inc., 59 Temple\\r\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\r\\n *\\r\\n * @package setPlaceholders\\r\\n * @author Jason Grant\\r\\n *\\r\\n * Documentation, examples, bug reports, etc.\\r\\n * https:\\/\\/github.com\\/oo12\\/setPlaceholders\\r\\n *\\r\\n * Variables\\r\\n * ---------\\r\\n * @var modX $modx\\r\\n *\\r\\n * Properties\\r\\n * ----------\\r\\n * @property integer id\\r\\n * @property string  ph\\r\\n * @property string  prefix\\r\\n * @property boolean output\\r\\n * @property string  delimiter\\r\\n * @property string  placeholders\\r\\n * @property string  sortby\\r\\n * @property string  sortdir\\r\\n * @property boolean processTVs\\r\\n *\\r\\n * See the default properties for a description of each.\\r\\n *\\r\\n * @package setPlaceholders\\r\\n **\\/\\r\\n\\r\\n\\/\\/ check and initialize essential properties\\r\\n$ph = empty($ph) ? array() : explode(\'||\', $ph);\\r\\n$placeholders = empty($placeholders) ? array() : explode(\'||\', $placeholders);\\r\\n$delimiter = isset($delimiter) ? $delimiter : \',\';\\r\\n$output = empty($output) ? FALSE : TRUE;\\r\\n\\r\\n$p = array();  \\/\\/ placeholder storage\\r\\nif ($ph) {\\r\\n\\t$id = empty($id) ? $modx->resource->get(\'id\') : (int) $id;\\r\\n\\t$prefix = isset($prefix) ? $prefix : \'sph.\';\\r\\n\\t$processTVs = empty($processTVs) ? FALSE : TRUE;\\r\\n\\t$sortby = empty($sortby) ? \'menuindex\' : $sortby;\\r\\n\\t$sortdir = empty($sortdir) ? \'ASC\' : $sortdir;\\r\\n\\t$staticCache = empty($staticCache) ? FALSE : TRUE;\\r\\n\\r\\n\\trequire_once MODX_CORE_PATH . \'components\\/setplaceholders\\/model\\/setplaceholders.class.php\';\\r\\n\\tstatic $sph_r_cache = array();  \\/\\/ cache for resource and TV objects\\r\\n\\t$sph = new sph($modx, $sph_r_cache, $id, $sortby, $sortdir, $processTVs);\\r\\n\\r\\n\\tforeach ($ph as $field) {\\r\\n\\t\\t$field = explode(\'!!\', $field);  \\/\\/ separate out any default value\\r\\n\\t\\t$varname = explode(\'==\', $field[0]);  \\/\\/ separate out any user-defined placeholder name\\r\\n\\t\\tif (isset($varname[1])) {  \\/\\/ if there is one, store the placeholder name\\r\\n\\t\\t\\t$field[0] = $varname[1];\\r\\n\\t\\t\\t$varname = trim($varname[0]);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t$varname = $prefix . trim($field[0]);  \\/\\/ go with prefix + field name\\r\\n\\t\\t}\\r\\n\\t\\tforeach ($field as $f) {  \\/\\/ run through the field and all fallbacks till we get a non-empty one\\r\\n\\t\\t\\t$value = $sph->getVal(trim($f));\\r\\n\\t\\t\\tif (!empty($value) || $value === 0)  { break; }  \\/\\/ quit as soon as we get something\\r\\n\\t\\t}\\r\\n\\t\\tif (is_array($value)) {  \\/\\/ special processing for migx\\r\\n\\t\\t\\t$varname .= \'.\';\\r\\n\\t\\t\\t$migx_idx = 1;\\r\\n\\t\\t\\tforeach ($value as $migx_row) {\\r\\n\\t\\t\\t\\tif (is_array($migx_row)) {\\r\\n\\t\\t\\t\\t\\t$migx_notfirst = FALSE;\\r\\n\\t\\t\\t\\t\\tforeach ($migx_row as $k=>$v) {  \\/\\/ set key:value pairs but ignore MIGX_id\\r\\n\\t\\t\\t\\t\\t\\tif ($migx_notfirst || $k !== \'MIGX_id\') {\\r\\n\\t\\t\\t\\t\\t\\t\\t$p[$varname . $k . $migx_idx] = $v;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t$migx_notfirst = TRUE;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t++$migx_idx;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$p[$varname . \'total\'] = $migx_idx - 1;  \\/\\/ set a placeholder with the total # of objects processed\\r\\n\\t\\t}\\r\\n\\t\\telse {  \\/\\/ set any not found items to \'\' so that placeholders will be fully parsed\\r\\n\\t\\t\\t$p[$varname] = ($value === NULL) ? \'\' : $value;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif (!$staticCache)  { $sph_r_cache = array(); }\\r\\n}\\r\\n\\r\\nforeach ($placeholders as $placeholder) { \\/\\/ add any user-defined placeholders\\r\\n\\t$ph = explode(\'==\', $placeholder);\\r\\n\\t$p[ trim($ph[0]) ] = trim($ph[1]);\\r\\n}\\r\\n\\r\\n\\/\\/ Output our results\\r\\n$modx->setPlaceholders($p);\\r\\nreturn $output ? implode($delimiter, $p) : \'\';","locked":0,"properties":"a:10:{s:2:\\"id\\";a:7:{s:4:\\"name\\";s:2:\\"id\\";s:4:\\"desc\\";s:16:\\"prop_sph.id_desc\\";s:4:\\"type\\";s:7:\\"integer\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:12:\\"placeholders\\";a:7:{s:4:\\"name\\";s:12:\\"placeholders\\";s:4:\\"desc\\";s:26:\\"prop_sph.placeholders_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:2:\\"ph\\";a:7:{s:4:\\"name\\";s:2:\\"ph\\";s:4:\\"desc\\";s:16:\\"prop_sph.ph_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:9:\\"delimiter\\";a:7:{s:4:\\"name\\";s:9:\\"delimiter\\";s:4:\\"desc\\";s:23:\\"prop_sph.delimiter_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\",\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"output\\";a:7:{s:4:\\"name\\";s:6:\\"output\\";s:4:\\"desc\\";s:20:\\"prop_sph.output_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"prefix\\";a:7:{s:4:\\"name\\";s:6:\\"prefix\\";s:4:\\"desc\\";s:20:\\"prop_sph.prefix_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:4:\\"sph.\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:10:\\"processTVs\\";a:7:{s:4:\\"name\\";s:10:\\"processTVs\\";s:4:\\"desc\\";s:24:\\"prop_sph.processTVs_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"sortby\\";a:7:{s:4:\\"name\\";s:6:\\"sortby\\";s:4:\\"desc\\";s:20:\\"prop_sph.sortby_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:9:\\"menuindex\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:23:\\"Child\\/Sibling Selectors\\";}s:7:\\"sortdir\\";a:7:{s:4:\\"name\\";s:7:\\"sortdir\\";s:4:\\"desc\\";s:21:\\"prop_sph.sortdir_desc\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:5:\\"value\\";s:3:\\"ASC\\";s:4:\\"text\\";s:3:\\"ASC\\";}i:1;a:2:{s:5:\\"value\\";s:4:\\"DESC\\";s:4:\\"text\\";s:4:\\"DESC\\";}}s:5:\\"value\\";s:3:\\"ASC\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:23:\\"Child\\/Sibling Selectors\\";}s:11:\\"staticCache\\";a:7:{s:4:\\"name\\";s:11:\\"staticCache\\";s:4:\\"desc\\";s:25:\\"prop_sph.staticCache_desc\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:5:\\"value\\";s:1:\\"1\\";s:4:\\"text\\";s:2:\\"On\\";}i:1;a:2:{s:5:\\"value\\";s:1:\\"0\\";s:4:\\"text\\";s:3:\\"Off\\";}}s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:7:\\"Caching\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\r\\n * setPlaceholders\\r\\n * Copyright 2013-2014 Jason Grant\\r\\n *\\r\\n * setPlaceholders is free software; you can redistribute it and\\/or modify it under the\\r\\n * terms of the GNU General Public License as published by the Free Software\\r\\n * Foundation; either version 2 of the License, or (at your option) any later\\r\\n * version.\\r\\n *\\r\\n * setPlaceholders is distributed in the hope that it will be useful, but WITHOUT ANY\\r\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\r\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\r\\n *\\r\\n * You should have received a copy of the GNU General Public License along with\\r\\n * setPlaceholders; if not, write to the Free Software Foundation, Inc., 59 Temple\\r\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\r\\n *\\r\\n * @package setPlaceholders\\r\\n * @author Jason Grant\\r\\n *\\r\\n * Documentation, examples, bug reports, etc.\\r\\n * https:\\/\\/github.com\\/oo12\\/setPlaceholders\\r\\n *\\r\\n * Variables\\r\\n * ---------\\r\\n * @var modX $modx\\r\\n *\\r\\n * Properties\\r\\n * ----------\\r\\n * @property integer id\\r\\n * @property string  ph\\r\\n * @property string  prefix\\r\\n * @property boolean output\\r\\n * @property string  delimiter\\r\\n * @property string  placeholders\\r\\n * @property string  sortby\\r\\n * @property string  sortdir\\r\\n * @property boolean processTVs\\r\\n *\\r\\n * See the default properties for a description of each.\\r\\n *\\r\\n * @package setPlaceholders\\r\\n **\\/\\r\\n\\r\\n\\/\\/ check and initialize essential properties\\r\\n$ph = empty($ph) ? array() : explode(\'||\', $ph);\\r\\n$placeholders = empty($placeholders) ? array() : explode(\'||\', $placeholders);\\r\\n$delimiter = isset($delimiter) ? $delimiter : \',\';\\r\\n$output = empty($output) ? FALSE : TRUE;\\r\\n\\r\\n$p = array();  \\/\\/ placeholder storage\\r\\nif ($ph) {\\r\\n\\t$id = empty($id) ? $modx->resource->get(\'id\') : (int) $id;\\r\\n\\t$prefix = isset($prefix) ? $prefix : \'sph.\';\\r\\n\\t$processTVs = empty($processTVs) ? FALSE : TRUE;\\r\\n\\t$sortby = empty($sortby) ? \'menuindex\' : $sortby;\\r\\n\\t$sortdir = empty($sortdir) ? \'ASC\' : $sortdir;\\r\\n\\t$staticCache = empty($staticCache) ? FALSE : TRUE;\\r\\n\\r\\n\\trequire_once MODX_CORE_PATH . \'components\\/setplaceholders\\/model\\/setplaceholders.class.php\';\\r\\n\\tstatic $sph_r_cache = array();  \\/\\/ cache for resource and TV objects\\r\\n\\t$sph = new sph($modx, $sph_r_cache, $id, $sortby, $sortdir, $processTVs);\\r\\n\\r\\n\\tforeach ($ph as $field) {\\r\\n\\t\\t$field = explode(\'!!\', $field);  \\/\\/ separate out any default value\\r\\n\\t\\t$varname = explode(\'==\', $field[0]);  \\/\\/ separate out any user-defined placeholder name\\r\\n\\t\\tif (isset($varname[1])) {  \\/\\/ if there is one, store the placeholder name\\r\\n\\t\\t\\t$field[0] = $varname[1];\\r\\n\\t\\t\\t$varname = trim($varname[0]);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t$varname = $prefix . trim($field[0]);  \\/\\/ go with prefix + field name\\r\\n\\t\\t}\\r\\n\\t\\tforeach ($field as $f) {  \\/\\/ run through the field and all fallbacks till we get a non-empty one\\r\\n\\t\\t\\t$value = $sph->getVal(trim($f));\\r\\n\\t\\t\\tif (!empty($value) || $value === 0)  { break; }  \\/\\/ quit as soon as we get something\\r\\n\\t\\t}\\r\\n\\t\\tif (is_array($value)) {  \\/\\/ special processing for migx\\r\\n\\t\\t\\t$varname .= \'.\';\\r\\n\\t\\t\\t$migx_idx = 1;\\r\\n\\t\\t\\tforeach ($value as $migx_row) {\\r\\n\\t\\t\\t\\tif (is_array($migx_row)) {\\r\\n\\t\\t\\t\\t\\t$migx_notfirst = FALSE;\\r\\n\\t\\t\\t\\t\\tforeach ($migx_row as $k=>$v) {  \\/\\/ set key:value pairs but ignore MIGX_id\\r\\n\\t\\t\\t\\t\\t\\tif ($migx_notfirst || $k !== \'MIGX_id\') {\\r\\n\\t\\t\\t\\t\\t\\t\\t$p[$varname . $k . $migx_idx] = $v;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t$migx_notfirst = TRUE;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t++$migx_idx;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$p[$varname . \'total\'] = $migx_idx - 1;  \\/\\/ set a placeholder with the total # of objects processed\\r\\n\\t\\t}\\r\\n\\t\\telse {  \\/\\/ set any not found items to \'\' so that placeholders will be fully parsed\\r\\n\\t\\t\\t$p[$varname] = ($value === NULL) ? \'\' : $value;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif (!$staticCache)  { $sph_r_cache = array(); }\\r\\n}\\r\\n\\r\\nforeach ($placeholders as $placeholder) { \\/\\/ add any user-defined placeholders\\r\\n\\t$ph = explode(\'==\', $placeholder);\\r\\n\\t$p[ trim($ph[0]) ] = trim($ph[1]);\\r\\n}\\r\\n\\r\\n\\/\\/ Output our results\\r\\n$modx->setPlaceholders($p);\\r\\nreturn $output ? implode($delimiter, $p) : \'\';"}',
        'guid' => 'daf3991930023c9ae9238c28b038ecb1',
        'native_key' => 2,
        'signature' => 'a08668ffb142f3508853fd4a3574ba43',
      ),
      '935d2474aeffe6fd4525819bbd889dbf' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":3,"source":0,"property_preprocess":0,"name":"spho","description":"An short alias for setPlaceholders, with output returned (&output=`1`)","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\r\\n * setPlaceholders\\r\\n * Copyright 2013-2014 Jason Grant\\r\\n *\\r\\n * setPlaceholders is free software; you can redistribute it and\\/or modify it under the\\r\\n * terms of the GNU General Public License as published by the Free Software\\r\\n * Foundation; either version 2 of the License, or (at your option) any later\\r\\n * version.\\r\\n *\\r\\n * setPlaceholders is distributed in the hope that it will be useful, but WITHOUT ANY\\r\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\r\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\r\\n *\\r\\n * You should have received a copy of the GNU General Public License along with\\r\\n * setPlaceholders; if not, write to the Free Software Foundation, Inc., 59 Temple\\r\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\r\\n *\\r\\n * @package setPlaceholders\\r\\n * @author Jason Grant\\r\\n *\\r\\n * Documentation, examples, bug reports, etc.\\r\\n * https:\\/\\/github.com\\/oo12\\/setPlaceholders\\r\\n *\\r\\n * Variables\\r\\n * ---------\\r\\n * @var modX $modx\\r\\n *\\r\\n * Properties\\r\\n * ----------\\r\\n * @property integer id\\r\\n * @property string  ph\\r\\n * @property string  prefix\\r\\n * @property boolean output\\r\\n * @property string  delimiter\\r\\n * @property string  placeholders\\r\\n * @property string  sortby\\r\\n * @property string  sortdir\\r\\n * @property boolean processTVs\\r\\n *\\r\\n * See the default properties for a description of each.\\r\\n *\\r\\n * @package setPlaceholders\\r\\n **\\/\\r\\n\\r\\n\\/\\/ check and initialize essential properties\\r\\n$ph = empty($ph) ? array() : explode(\'||\', $ph);\\r\\n$placeholders = empty($placeholders) ? array() : explode(\'||\', $placeholders);\\r\\n$delimiter = isset($delimiter) ? $delimiter : \',\';\\r\\n$output = empty($output) ? FALSE : TRUE;\\r\\n\\r\\n$p = array();  \\/\\/ placeholder storage\\r\\nif ($ph) {\\r\\n\\t$id = empty($id) ? $modx->resource->get(\'id\') : (int) $id;\\r\\n\\t$prefix = isset($prefix) ? $prefix : \'sph.\';\\r\\n\\t$processTVs = empty($processTVs) ? FALSE : TRUE;\\r\\n\\t$sortby = empty($sortby) ? \'menuindex\' : $sortby;\\r\\n\\t$sortdir = empty($sortdir) ? \'ASC\' : $sortdir;\\r\\n\\t$staticCache = empty($staticCache) ? FALSE : TRUE;\\r\\n\\r\\n\\trequire_once MODX_CORE_PATH . \'components\\/setplaceholders\\/model\\/setplaceholders.class.php\';\\r\\n\\tstatic $sph_r_cache = array();  \\/\\/ cache for resource and TV objects\\r\\n\\t$sph = new sph($modx, $sph_r_cache, $id, $sortby, $sortdir, $processTVs);\\r\\n\\r\\n\\tforeach ($ph as $field) {\\r\\n\\t\\t$field = explode(\'!!\', $field);  \\/\\/ separate out any default value\\r\\n\\t\\t$varname = explode(\'==\', $field[0]);  \\/\\/ separate out any user-defined placeholder name\\r\\n\\t\\tif (isset($varname[1])) {  \\/\\/ if there is one, store the placeholder name\\r\\n\\t\\t\\t$field[0] = $varname[1];\\r\\n\\t\\t\\t$varname = trim($varname[0]);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t$varname = $prefix . trim($field[0]);  \\/\\/ go with prefix + field name\\r\\n\\t\\t}\\r\\n\\t\\tforeach ($field as $f) {  \\/\\/ run through the field and all fallbacks till we get a non-empty one\\r\\n\\t\\t\\t$value = $sph->getVal(trim($f));\\r\\n\\t\\t\\tif (!empty($value) || $value === 0)  { break; }  \\/\\/ quit as soon as we get something\\r\\n\\t\\t}\\r\\n\\t\\tif (is_array($value)) {  \\/\\/ special processing for migx\\r\\n\\t\\t\\t$varname .= \'.\';\\r\\n\\t\\t\\t$migx_idx = 1;\\r\\n\\t\\t\\tforeach ($value as $migx_row) {\\r\\n\\t\\t\\t\\tif (is_array($migx_row)) {\\r\\n\\t\\t\\t\\t\\t$migx_notfirst = FALSE;\\r\\n\\t\\t\\t\\t\\tforeach ($migx_row as $k=>$v) {  \\/\\/ set key:value pairs but ignore MIGX_id\\r\\n\\t\\t\\t\\t\\t\\tif ($migx_notfirst || $k !== \'MIGX_id\') {\\r\\n\\t\\t\\t\\t\\t\\t\\t$p[$varname . $k . $migx_idx] = $v;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t$migx_notfirst = TRUE;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t++$migx_idx;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$p[$varname . \'total\'] = $migx_idx - 1;  \\/\\/ set a placeholder with the total # of objects processed\\r\\n\\t\\t}\\r\\n\\t\\telse {  \\/\\/ set any not found items to \'\' so that placeholders will be fully parsed\\r\\n\\t\\t\\t$p[$varname] = ($value === NULL) ? \'\' : $value;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif (!$staticCache)  { $sph_r_cache = array(); }\\r\\n}\\r\\n\\r\\nforeach ($placeholders as $placeholder) { \\/\\/ add any user-defined placeholders\\r\\n\\t$ph = explode(\'==\', $placeholder);\\r\\n\\t$p[ trim($ph[0]) ] = trim($ph[1]);\\r\\n}\\r\\n\\r\\n\\/\\/ Output our results\\r\\n$modx->setPlaceholders($p);\\r\\nreturn $output ? implode($delimiter, $p) : \'\';","locked":0,"properties":"a:10:{s:2:\\"id\\";a:7:{s:4:\\"name\\";s:2:\\"id\\";s:4:\\"desc\\";s:16:\\"prop_sph.id_desc\\";s:4:\\"type\\";s:7:\\"integer\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:12:\\"placeholders\\";a:7:{s:4:\\"name\\";s:12:\\"placeholders\\";s:4:\\"desc\\";s:26:\\"prop_sph.placeholders_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:2:\\"ph\\";a:7:{s:4:\\"name\\";s:2:\\"ph\\";s:4:\\"desc\\";s:16:\\"prop_sph.ph_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:5:\\"Input\\";}s:9:\\"delimiter\\";a:7:{s:4:\\"name\\";s:9:\\"delimiter\\";s:4:\\"desc\\";s:23:\\"prop_sph.delimiter_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\",\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"output\\";a:7:{s:4:\\"name\\";s:6:\\"output\\";s:4:\\"desc\\";s:20:\\"prop_sph.output_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:1;s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"prefix\\";a:7:{s:4:\\"name\\";s:6:\\"prefix\\";s:4:\\"desc\\";s:20:\\"prop_sph.prefix_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:4:\\"sph.\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:10:\\"processTVs\\";a:7:{s:4:\\"name\\";s:10:\\"processTVs\\";s:4:\\"desc\\";s:24:\\"prop_sph.processTVs_desc\\";s:4:\\"type\\";s:13:\\"combo-boolean\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";b:0;s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:6:\\"Output\\";}s:6:\\"sortby\\";a:7:{s:4:\\"name\\";s:6:\\"sortby\\";s:4:\\"desc\\";s:20:\\"prop_sph.sortby_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:9:\\"menuindex\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:23:\\"Child\\/Sibling Selectors\\";}s:7:\\"sortdir\\";a:7:{s:4:\\"name\\";s:7:\\"sortdir\\";s:4:\\"desc\\";s:21:\\"prop_sph.sortdir_desc\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:5:\\"value\\";s:3:\\"ASC\\";s:4:\\"text\\";s:3:\\"ASC\\";}i:1;a:2:{s:5:\\"value\\";s:4:\\"DESC\\";s:4:\\"text\\";s:4:\\"DESC\\";}}s:5:\\"value\\";s:3:\\"ASC\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:23:\\"Child\\/Sibling Selectors\\";}s:11:\\"staticCache\\";a:7:{s:4:\\"name\\";s:11:\\"staticCache\\";s:4:\\"desc\\";s:25:\\"prop_sph.staticCache_desc\\";s:4:\\"type\\";s:4:\\"list\\";s:7:\\"options\\";a:2:{i:0;a:2:{s:5:\\"value\\";s:1:\\"1\\";s:4:\\"text\\";s:2:\\"On\\";}i:1;a:2:{s:5:\\"value\\";s:1:\\"0\\";s:4:\\"text\\";s:3:\\"Off\\";}}s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:23:\\"setplaceholders:default\\";s:4:\\"area\\";s:7:\\"Caching\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\r\\n * setPlaceholders\\r\\n * Copyright 2013-2014 Jason Grant\\r\\n *\\r\\n * setPlaceholders is free software; you can redistribute it and\\/or modify it under the\\r\\n * terms of the GNU General Public License as published by the Free Software\\r\\n * Foundation; either version 2 of the License, or (at your option) any later\\r\\n * version.\\r\\n *\\r\\n * setPlaceholders is distributed in the hope that it will be useful, but WITHOUT ANY\\r\\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\\r\\n * A PARTICULAR PURPOSE. See the GNU General Public License for more details.\\r\\n *\\r\\n * You should have received a copy of the GNU General Public License along with\\r\\n * setPlaceholders; if not, write to the Free Software Foundation, Inc., 59 Temple\\r\\n * Place, Suite 330, Boston, MA 02111-1307 USA\\r\\n *\\r\\n * @package setPlaceholders\\r\\n * @author Jason Grant\\r\\n *\\r\\n * Documentation, examples, bug reports, etc.\\r\\n * https:\\/\\/github.com\\/oo12\\/setPlaceholders\\r\\n *\\r\\n * Variables\\r\\n * ---------\\r\\n * @var modX $modx\\r\\n *\\r\\n * Properties\\r\\n * ----------\\r\\n * @property integer id\\r\\n * @property string  ph\\r\\n * @property string  prefix\\r\\n * @property boolean output\\r\\n * @property string  delimiter\\r\\n * @property string  placeholders\\r\\n * @property string  sortby\\r\\n * @property string  sortdir\\r\\n * @property boolean processTVs\\r\\n *\\r\\n * See the default properties for a description of each.\\r\\n *\\r\\n * @package setPlaceholders\\r\\n **\\/\\r\\n\\r\\n\\/\\/ check and initialize essential properties\\r\\n$ph = empty($ph) ? array() : explode(\'||\', $ph);\\r\\n$placeholders = empty($placeholders) ? array() : explode(\'||\', $placeholders);\\r\\n$delimiter = isset($delimiter) ? $delimiter : \',\';\\r\\n$output = empty($output) ? FALSE : TRUE;\\r\\n\\r\\n$p = array();  \\/\\/ placeholder storage\\r\\nif ($ph) {\\r\\n\\t$id = empty($id) ? $modx->resource->get(\'id\') : (int) $id;\\r\\n\\t$prefix = isset($prefix) ? $prefix : \'sph.\';\\r\\n\\t$processTVs = empty($processTVs) ? FALSE : TRUE;\\r\\n\\t$sortby = empty($sortby) ? \'menuindex\' : $sortby;\\r\\n\\t$sortdir = empty($sortdir) ? \'ASC\' : $sortdir;\\r\\n\\t$staticCache = empty($staticCache) ? FALSE : TRUE;\\r\\n\\r\\n\\trequire_once MODX_CORE_PATH . \'components\\/setplaceholders\\/model\\/setplaceholders.class.php\';\\r\\n\\tstatic $sph_r_cache = array();  \\/\\/ cache for resource and TV objects\\r\\n\\t$sph = new sph($modx, $sph_r_cache, $id, $sortby, $sortdir, $processTVs);\\r\\n\\r\\n\\tforeach ($ph as $field) {\\r\\n\\t\\t$field = explode(\'!!\', $field);  \\/\\/ separate out any default value\\r\\n\\t\\t$varname = explode(\'==\', $field[0]);  \\/\\/ separate out any user-defined placeholder name\\r\\n\\t\\tif (isset($varname[1])) {  \\/\\/ if there is one, store the placeholder name\\r\\n\\t\\t\\t$field[0] = $varname[1];\\r\\n\\t\\t\\t$varname = trim($varname[0]);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t$varname = $prefix . trim($field[0]);  \\/\\/ go with prefix + field name\\r\\n\\t\\t}\\r\\n\\t\\tforeach ($field as $f) {  \\/\\/ run through the field and all fallbacks till we get a non-empty one\\r\\n\\t\\t\\t$value = $sph->getVal(trim($f));\\r\\n\\t\\t\\tif (!empty($value) || $value === 0)  { break; }  \\/\\/ quit as soon as we get something\\r\\n\\t\\t}\\r\\n\\t\\tif (is_array($value)) {  \\/\\/ special processing for migx\\r\\n\\t\\t\\t$varname .= \'.\';\\r\\n\\t\\t\\t$migx_idx = 1;\\r\\n\\t\\t\\tforeach ($value as $migx_row) {\\r\\n\\t\\t\\t\\tif (is_array($migx_row)) {\\r\\n\\t\\t\\t\\t\\t$migx_notfirst = FALSE;\\r\\n\\t\\t\\t\\t\\tforeach ($migx_row as $k=>$v) {  \\/\\/ set key:value pairs but ignore MIGX_id\\r\\n\\t\\t\\t\\t\\t\\tif ($migx_notfirst || $k !== \'MIGX_id\') {\\r\\n\\t\\t\\t\\t\\t\\t\\t$p[$varname . $k . $migx_idx] = $v;\\r\\n\\t\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t\\t$migx_notfirst = TRUE;\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t\\t++$migx_idx;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\t$p[$varname . \'total\'] = $migx_idx - 1;  \\/\\/ set a placeholder with the total # of objects processed\\r\\n\\t\\t}\\r\\n\\t\\telse {  \\/\\/ set any not found items to \'\' so that placeholders will be fully parsed\\r\\n\\t\\t\\t$p[$varname] = ($value === NULL) ? \'\' : $value;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif (!$staticCache)  { $sph_r_cache = array(); }\\r\\n}\\r\\n\\r\\nforeach ($placeholders as $placeholder) { \\/\\/ add any user-defined placeholders\\r\\n\\t$ph = explode(\'==\', $placeholder);\\r\\n\\t$p[ trim($ph[0]) ] = trim($ph[1]);\\r\\n}\\r\\n\\r\\n\\/\\/ Output our results\\r\\n$modx->setPlaceholders($p);\\r\\nreturn $output ? implode($delimiter, $p) : \'\';"}',
        'guid' => 'e78afc00fceab6e24224d4541d46eb85',
        'native_key' => 3,
        'signature' => '81f7abf32d9dcfecabb3f17a60e742fd',
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
  ),
  'namespace' => 'setplaceholders',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'file',
      'body' => '{"source":"setplaceholders-2.2.1-pl\\/modCategory\\/5e88aa337684b6709ad74f21a83e3255\\/0\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"setplaceholders"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => 'c5560d20ccd084cb54a6195bff566a9a',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => '5e88aa337684b6709ad74f21a83e3255',
  'native_key' => 1,
  'object' => '{"id":1,"parent":0,"category":"setPlaceholders"}',
);